---
title: "¿Dónde es mejor sembrar maíz según la temperatura en indiana?"
output: 
  html_document:
    css: "styles.css"
    includes:
      before_body: static/slider/index.html
    toc: true
    theme: paper
    code_folding: show
    toc_float: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, fig.pos = "H", fig.align = "center")
library(knitr)
library(tidyverse)
library(kableExtra)
library(leaflet)
library(ade4)
library(vegan)
library(rgdal)
library(geoR)
library(raster)
library(sf)
library(gstat)
library(stars)
```

```{r datos}
datos <- read.csv("datos_crudos.csv")

datos_def <- readRDS("datos.Rds")
```

# Contextualización

El invierno es feroz, más aún cuando de agricultura se trata. Indiana, estado 
precioso cuyo mayor costo de <a href="https://www.nass.usda.gov/Quick_Stats/Ag_Overview/stateOverview.php?state=INDIANA">producción agrícola</a> se debe al cultivo de maíz.

Motivados por este hecho, se tomó la decisión de investigar cuáles son
aquellas zonas en las que se presenta una mayor temperatura y una mayor
irradiación por parte de la radiación que emite la luz solar, ya que
el maíz es un vegetal que aprovecha mucho ambas características para
su <a href="https://www.pioneer.com/us/agronomy/soil_temp_corn_emergence.html#:~:text=Key%20Points,corn%20emergence%20and%20seedling%20health.">crecimiento y desarrollo</a>.

# Temperatura e irradiación solar 

Se miden las variables irradiación solar y temperatura en ubicaciones especificas del estado de indiana en estados unidos múltiples veces (90 en cada punto); dichas mediciones se realizan en ubicaciones igualmente espaciadas. 

Teniendo en cuenta que se tienen múltiples mediciones de las variables surge la necesidad de resumir esta información con alguna métrica puesto que en la teoría vista se considera una única realización del proceso estocástico, a continuación se muestran los histogramas de las variables consideradas.

```{r histogramas}
p1 <- ggplot(datos, aes(T2MWET)) +
  geom_histogram(bins =  nclass.Sturges(datos$T2MWET),
                 col = "black", fill = "cyan") +
  labs(x = "Temperatura", y = "Frecuencia",
       title = "Distribución de temperatura") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
p2 <- ggplot(datos, aes(ALLSKY_SFC_LW_DWN)) +
  geom_histogram(bins =  nclass.Sturges(datos$ALLSKY_SFC_LW_DWN),
                 col = "black", fill = "cyan") +
  labs(x = "Irradiación", y = "Frecuencia",
       title = "Distribución de irradiación solar") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
ggpubr::ggarrange(p1, p2, nrow = 1)
```   

Dada la aparente simetría en los histogramas, simplificar las mediciones de dichas variables con sus respectivos promedios y meidanas no es una idea 
descabellada.

# Base de datos definitiva

La base de datos definitiva se construye agrupando los datos por la longitud y 
latitud debido a que, como se mencionó previamente, se tienen múltiples 
mediciones de las variables en cada ubicación, los cuales corresponden a los 
primeros tres meses del año. Una vez agrupadas las ubicaciones, se promedian 
todos los valores medidos en dichas ubicaciones de las variables de interés, 
esto gracias a las funciones `group_by()` y `summarise()` de la librería 
`dplyr`. La base de datos resultante tiene la siguiente estructura

```{r datos-def}
kable(datos_def[1:5,], 
    col.names = c("Latitud", "Longitud",
                  "Irradiación media", "Irradiación mediana",
                  "Temperatura media", "Temperatura mediana"),
    caption = "Presentación de algunos datos") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Para finalizar se muestra el mapa de las ubicaciones de muestreo.

```{r}
mapa_base <- leaflet() %>%
  addTiles()
mapa_base %>% 
  addMarkers(lat=~LAT, lng =~LON, data = datos_def,
                   icon = makeIcon(iconUrl = "./static/corn.png",
                            iconWidth = 24, iconHeight = 24),
             popup = paste(
               "<h3>Información resumen</h3>",
               paste("Irradiación media:",
                     round(datos_def$Irradiacion, 2)),
               paste("Irradiación mediana:",
                     round(datos_def$IrradiacionMediana), 2),
               paste("Temperatura media:", 
                     round(datos_def$Temperatura, 2)),
               paste("Temperatura meidana:", 
                     round(datos_def$TemperaturaMediana),2),
               sep = "<br>"
             )
  )
```


```{r}
temp <- project(as.matrix(datos_def[, 2:1]), "+proj=utm +zone=16 ellps=WGS84")
colnames(temp) <- c("x", "y")
datos_def <- cbind(datos_def, temp)
geodist <- dist(datos_def[,7:8], diag=TRUE, upper=TRUE)

# Matriz de distancias entre las observacioens registradas 
# en los lugares de muestreo de temperatura
dist.irra <- dist(datos_def[,3], diag=TRUE, upper=TRUE)^2
dist.temp <- dist(datos_def[,5], diag=TRUE, upper=TRUE)^2
dist.irra.median <- dist(datos_def[,4], diag=TRUE, upper=TRUE)^2
dist.temp.median <- dist(datos_def[,6], diag=TRUE, upper=TRUE)^2
df <- data.frame(Disimilitud0=dist.temp[lower.tri(dist.temp)],
                 Disimilitud1=dist.irra[lower.tri(dist.irra)],
                 Disimilitud2=dist.temp.median[lower.tri(dist.temp.median)],
                 Disimilitud3=dist.irra.median[lower.tri(dist.irra.median)],
                 Distancia=geodist[lower.tri(geodist)])

```

# Chequeo de autocorrelación espacial {.tabset .tabset-fade .tabset-pills}

A continuación se chequea rapidamente la autocorrelación espacial pues si esta no existiera cualquier tipo de análisis posterior carecería de sentido

## Argumento gráfico

```{r, warning=FALSE, message=FALSE}
p0 <- ggplot(df, aes(x=Distancia, y=Disimilitud0)) +
  geom_point() + 
  theme_test(base_size = 14, base_family = "Times New Roman") + 
  labs(title  = "Temperatura promedio", x = "Distancia geográfica",
       y = "Disimilitud") + 
  theme_minimal() +
  theme(axis.title = element_text(face="bold"), 
        axis.text = element_text(colour="black"),
        plot.title = element_text(hjust = 0.5)) +
  geom_smooth(method = lm)

p1 <- ggplot(df, aes(x=Distancia, y=Disimilitud1)) + geom_point() + 
  theme_test(base_size = 14, base_family = "Times New Roman") + 
  labs(title = "Irradiación solar promedio", x = "Distancia geográfica",
       y = "Disimilitud") +
  theme_minimal() +
  theme(axis.title = element_text(face = "bold"), 
        axis.text = element_text(colour = "black"),
        plot.title = element_text(hjust = 0.5)) + 
  
  geom_smooth(method = lm)

p2 <- ggplot(df, aes(x=Distancia, y=Disimilitud2)) + geom_point() + 
  theme_test(base_size = 14, base_family = "Times New Roman") + 
  labs(title = "Temperatura mediana", x = "Distancia geográfica",
       y = "Disimilitud") +
  theme_minimal() +
  theme(axis.title = element_text(face = "bold"), 
        axis.text = element_text(colour = "black"),
        plot.title = element_text(hjust = 0.5)) + 
  
  geom_smooth(method = lm)

p3 <- ggplot(df, aes(x=Distancia, y=Disimilitud3)) + geom_point() + 
  theme_test(base_size = 14, base_family = "Times New Roman") + 
  labs(title = "Irradiación solar mediana", x = "Distancia geográfica",
       y = "Disimilitud") +
  theme_minimal() +
  theme(axis.title = element_text(face = "bold"), 
        axis.text = element_text(colour = "black"),
        plot.title = element_text(hjust = 0.5)) + 
  
  geom_smooth(method = lm)

ggpubr::ggarrange(p0, p1, p2, p3, ncol = 2, nrow = 2)

```

En todos los casos se puede observar una tendencia de asosiación entre la distancia geografica y las medidas de disimilitud lo cual sugiere la existencia de autocorrelación espacial para las variables temperatura e irradiación solar 

## Pruebas de mantel para autocorrelación espacial 

**Temperatura promedio**

```{r}
mantel(geodist, dist.temp)
```

**Irradiación solar promedio**

```{r}
mantel(geodist, dist.irra)
```
**Temperatura solar mediana**

```{r}
mantel(geodist, dist.temp.median)
```

**Irradiación solar mediana**

```{r}
mantel(geodist, dist.irra.median)
```

Para cada caso el valor p de la prueba es muy pequeño (menor a 0.001) con lo que a cualquier nivel de significancia usual se rechaza la hipótesis nula de independencia y se concluye que las variables tienen autocorrelación espacial.

<!-- juanjo -->
# Interpolación espacial

Dada la existencia de autocorrelación espacial, el siguiente paso es encontrar un modelo
útil para realizar predicciones espaciales la región de interés, es decir, el estado de 
indiana.

## Semivariograma

A continuación se presenta el ajuste de semivariogramas tipo bin para las variables
consideradas para 20 puntos usandos modelos gaussiano, exponencial y esférico
respectivamente.

```{r echo=F}
datos_geo<- as.geodata(datos_def, coords.col = 7:8,
                       data.col = 3:6)
```


```{r warning=F, message=F}
variogramas <- list()
bandas_conf <- list()

ini.vals <- expand.grid(seq(10, 40, l = 10), seq(50000, 150000, l = 10))
model_mco_exps <- list()
model_mco_gaus <- list()
model_mco_spes <- list()
for(i in 1:4){
  variograma <- variog(datos_geo, data = datos_geo$data[, i], 
                       option = "bin",
                       uvec = seq(10000, 270000, length.out = 20),
                       messages = F)
  variogramas[[i]] <- variograma
  
  ## bandas de confianza, si hay o no autocorrelacion 
  variograma.emv <- variog.mc.env(datos_geo, data = datos_geo$data[, i],
                                  obj = variograma, messages = F)
  bandas_conf[[i]] <- variograma.emv
  
  model_mco_exps[[i]] <- variofit(variogramas[[i]], ini = ini.vals,
                                  cov.model = "exponential",
                                  wei = "npair", min = "optim", messages = F)
  model_mco_gaus[[i]] <- variofit(variogramas[[i]], ini = ini.vals,
                          cov.model = "gaussian", 
                          wei = "npair", min = "optim", nugget = 0, messages = F)
  model_mco_spes[[i]] <- variofit(variogramas[[i]], ini = ini.vals,
                       cov.model = "spheric", fix.nug = TRUE,
                       wei = "npair", min = "optim", messages = F)

}
```


```{r}
par(mfrow = c(2, 2))
Titulos <- c("Irradiación promedio", "Irradiación mediana", 
             "Temperatura promedio", "Temperatura mediana")
for(i in 1:4){
  plot(variogramas[[i]], envelope = bandas_conf[[i]], 
       pch = 19, las = 1, main = Titulos[[i]],
       xlab = "Distancia [m]", ylab = "Semivarianza")
  lines(model_mco_exps[[i]], col="blue")
  lines(model_mco_gaus[[i]], col="red")
  lines(model_mco_spes[[i]], col="purple")
  legend("topleft", c("Gauss","Expo","Spe"),
         col = c("red","blue","purple"), lwd = 1, cex = 0.5)
}
```

En primera instancia se destaca la autocorrelación espacial (que ya se habia verificado
previamente) debido a que una considerable cantidad de puntos caen fuera de las bandas
de confianza. 
Se puede apreciar que, en general, los puntos no están acotados lo cual es una señal de 
que la meseta es no finita y por la tanto se tendría estacionariedad intrínseca, por lo
tanto es adecuado considerar modelos que puedan modelar tendencia en la media.
Finalmente, se destaca que el modelo de semivarianza que mejor se ajusta es el gaussiano
mientras que el esférico y esxponencial presentan comportamientos similares.

## Kriging ordinario {.tabset .tabset-fade .tabset-pills}

Se realiza realiza el ajuste de kriging ordinario usando el método de mínimos cuadrados
ordinarios. este tipo de kriging es el más sencillo y es usado en primera instancia para
observar el comportamiento de las predicciones espaciales con los diferentes modelos
de semivarianza.

```{r, include=F}
#xmin: 403477.8 ymin: 4180915 xmax: 692181.8 ymax: 4625475
prediction_grid <- expand.grid(seq(403477.8, 692181.8, 
                                   length.out = 100),
                               seq(4180915, 4625475,
                                   length.out = 100))
# Listas vacias
map_image_gaus.ko <- list()
map_image_exps.ko <- list()
map_image_spes.ko <- list()

krig_gaus.ko <- list()
krig_exps.ko <- list()
krig_spes.ko <- list()

map_image_gausvar.ko <- list()
map_image_expsvar.ko <- list()
map_image_spesvar.ko <- list()

for(i in 1:4){
  # Modelo gaussiano
  krig_gaus.ko[[i]] <- krige.conv(datos_geo, data = datos_geo$data[, i],
                               loc = prediction_grid,
                          krige = 
                            krige.control(obj.model = model_mco_gaus[[i]]))
  
  map_image_gaus.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             krig_gaus.ko[[i]]$predict))
  
  map_image_gausvar.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             sqrt(krig_gaus.ko[[i]]$krige.var)))
  #Modelo Exponencial
  krig_exps.ko[[i]] <- krige.conv(datos_geo, data = datos_geo$data[, i],
                               loc = prediction_grid,
                          krige = 
                            krige.control(obj.model = model_mco_exps[[i]]))
  
  map_image_exps.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             krig_exps.ko[[i]]$predict))
  
  map_image_expsvar.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             sqrt(krig_exps.ko[[i]]$krige.var)))
  
  # Modelo esferico
  krig_spes.ko[[i]] <- krige.conv(datos_geo, data = datos_geo$data[, i],
                               loc = prediction_grid,
                          krige = 
                            krige.control(obj.model = model_mco_spes[[i]]))
  
  map_image_spes.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             krig_spes.ko[[i]]$predict))
  
   map_image_spesvar.ko[[i]] <- rasterFromXYZ(data.frame(prediction_grid,
                                             sqrt(krig_spes.ko[[i]]$krige.var)))
}
```


```{r, message=F}
raster.ko <- list(map_image_gaus.ko, map_image_exps.ko, map_image_spes.ko)
vars.ko <- list(map_image_gausvar.ko, map_image_expsvar.ko, map_image_spesvar.ko)
nombres_modelos <- c("Modelo gaussiano", "Modelo exponencial",
                     "Modelo esférico")
modelos <- list(model_mco_gaus, model_mco_exps, model_mco_spes)
xvs <- c()
labels <- c()

maps.plot <- function(i, j, plot.var = F) {
  #par(mfrow = c(1, 2))
    label <- paste(Titulos[i], "\n",nombres_modelos[j])
    if (!plot.var) {
      plot(raster.ko[[j]][[i]],
         main = paste(label, "(predicción)"), cex.main = 0.8,
         col = viridis::inferno(20), xaxt = "n", yaxt = "n",
         xlim = c(403476, 692182))
    } else {
      plot(vars.ko[[j]][[i]], main = paste(label, "(desviación estándar)"),
         cex.main = 0.8, col = viridis::inferno(20), xaxt = "n", yaxt = "n",
         xlim = c(403476, 692182))
    }
    xv <- xvalid(datos_geo, data = datos_geo$data[, i],
               model = modelos[[j]][[i]])$error^2
    xvs <- append(xvs, mean(xv))
    labels <- append(labels, str_replace(label, " \\n ", " "))
}
```

### Irradiación Promedio {.tabset .tabset-fade .tabset-pills}

#### Modelo gaussiano {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(1, 1)
```

##### Desviación 

```{r, results='hide'}
maps.plot(1, 1, T)
```

#### Modelo exponencial {.tabset .tabset-fade .tabset-pills}

##### Predicción

```{r, results='hide'}
maps.plot(1, 2)
```

##### Desviación 

```{r, results='hide'}
maps.plot(1, 2, T)
```

#### Modelo esférico {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(1, 3)
```

##### Desviación 

```{r, results='hide'}
maps.plot(1, 3, T)
```

### Irradiación mediana {.tabset .tabset-fade .tabset-pills}

#### Modelo gaussiano {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(2, 1)
```

##### Desviación 

```{r, results='hide'}
maps.plot(2, 1, T)
```

#### Modelo exponencial {.tabset .tabset-fade .tabset-pills}

##### Predicción

```{r, results='hide'}
maps.plot(2, 2)
```

##### Desviación 

```{r, results='hide'}
maps.plot(2, 2, T)
```

#### Modelo esférico {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(3, 1)
```

##### Desviación 

```{r, results='hide'}
maps.plot(3, 1, T)
```

### Temperatura promedio {.tabset .tabset-fade .tabset-pills}

#### Modelo gaussiano {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(3, 1)
```

Se puede observar que entre todos los modelos de kriging ordinario,
el que mejor desempeño presenta es aquel donde se asume una estructura
de covarianza gaussiana para predecir la temperatura promedio.

```{r}
crossval.ok <- readRDS("crossvalok.Rds")
crossval.ok %>% 
  kable(col.names = c("Descripción", "RMSE"),
        caption = "Comparación de ajustes vía kriging ordinario") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```


Dicho lo anterior y teniendo en cuenta la alta correlación entre las 
variables repuesta (redundancia) como se puede ver en el gráfico 
que se muestra inmediatamente abajo, los posteriores análisis se realizarán
teniendo a la temperatura promedio como única variable respuesta.


```{r}
cors <- round(cor(datos_def[, 3:6]), 4)
cors[upper.tri(cors)] <- NA

cors <- reshape2::melt(cors, na.rm = T)

ggplot(cors, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  geom_text(aes(label = value)) +
  labs(x = "", y = "", title = "Matriz de correlaciones") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = .5)) +
  scale_fill_gradientn(colors = viridis::viridis(20))
```


##### Desviación 

```{r, results='hide'}
maps.plot(3, 1, T)
```


#### Modelo exponencial {.tabset .tabset-fade .tabset-pills}

##### Predicción

```{r, results='hide'}
maps.plot(3, 2)
```

##### Desviación 

```{r, results='hide'}
maps.plot(3, 2, T)
```

#### Modelo esférico {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(3, 3)
```

##### Desviación 

```{r, results='hide'}
maps.plot(3, 3, T)
```

### Temperatura mediana {.tabset .tabset-fade .tabset-pills}

#### Modelo gaussiano {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(4, 1)
```

##### Desviación 

```{r, results='hide'}
maps.plot(4, 1, T)
```

#### Modelo exponencial {.tabset .tabset-fade .tabset-pills}

##### Predicción

```{r, results='hide'}
maps.plot(4, 2)
```

##### Desviación 

```{r, results='hide'}
maps.plot(4, 2, T)
```

#### Modelo esférico {.tabset .tabset-fade .tabset-pills}

##### Predicción 

```{r, results='hide'}
maps.plot(4, 3)
```

##### Desviación 

```{r, results='hide'}
maps.plot(4, 3, T)
```


Luego de ajustar todos los modelos y realizar las respectivas predicciones se ve una
tendencia clara, los modelos exponencial y esféricos tienen comportamientos muy similares
en las predicciones realizadas y no son muy adecuados puesto que los valores de las
desviaciones estándar de predicción son muy bajos cerca de los puntos de muestreo pero
en ubicaciones un ligeramente distantes de estas dichos valores aumentan 
sustancialmente, sugiriendo que dichos modelos sobreajustan los datos. Por otro lado, los
modelos gaussianos constrastan totalmente con el exponencial y esferico pues las 
desviaciones estándar se mantienen bajas en la gran mayoría de ventana de predicción
sugiriendo una buena capacidad de generalizar la tendencia.


## Kriging universal {.tabset .tabset-fade .tabset-pills}

Si bien el kriging ordinario dio muy buenos resultados, hay que notar la
tendencia lineal existente entre la coordenada en y de los datos y la
respuesta considerada como se puede ver a continuación.

```{r}
plot(datos_geo)
```


Por tanto se opta por ajustar un modelo de kriging universal con media lineal en aras
de observar si dicha consideración mejora el rendimiento del modelo. Este fue
el resultado.

```{r, results='hide', warning=F}
#leyendo el shapefile
Indianashp <- st_read("IndianaFiles/tl_2017_18_cousub.shp")
#convirtiendolo en utm
Indianashputm <- st_transform(Indianashp, "+proj=utm +zone=16 ellps=WGS84")
spatial.points <- SpatialPoints(datos_def[, 7:8], 
                                proj4string = CRS("+proj=utm +zone=16 ellps=WGS84"))

# Se transforma a formato sf
datos_geo2 <- st_as_sf(as.data.frame(datos_geo), 
                       coords = c("x", "y"),
                       remove = FALSE, agr = "constant",
                       crs = "+proj=utm +zone=16 ellps=WGS84")

# Se construye el variograma muestral con tendencia (libreria gstat)
vario <- variogram(Temperatura ~ x + y, datos_geo2,
                   cutoff = 200000)

# Se ajusta un modelo de variograma gaussiano
fit <- fit.variogram(vario, vgm(model = "Gau", nugget = NA), fit.method = 2)

# Se define la malla de predicciones
buffer <- Indianashputm %>%
  st_geometry() %>%
  st_buffer(40)


grid <- buffer %>% 
  st_as_stars(nx = 100, ny = 100)

pred <- krige(formula = Temperatura ~ x + y,
              locations = datos_geo2, model = fit,
              newdata = grid)

grid$var1.pred <- pred$var1.pred
grid$var1.var <- pred$var1.var

```

Se puede notar que en cuanto a la predicción es distinto al modelo seleccionado
previamente, sin embargo el patrón en el mapa de calor de las predicciones
se ajusta más a lo que se esperaría en la realidad.

### Predicción 

```{r, results='hide'}
plot(grid["var1.pred"], breaks = "equal", 
     col = viridis::inferno(20), 
     key.pos = 4,
     main = "Kriging universal (predicciones)")
```


### Desviación


```{r, results='hide'}
plot(grid["var1.var"] %>% sqrt(), breaks = "equal",
     col = viridis::inferno(20), 
     key.pos = 4,
     main = "Kriging universal (desviación estándar)")
```

Una vez obtenido el resultado del modelo, este se compara con el
modelo ajustado vía kriging ordinario.


```{r}
cv.uk <- readRDS("cv_uk.Rds")
rmse.uk <- sqrt(mean((cv.uk$residual)^2))
comparison <- data.frame(
  Modelo = c("Temperatura promedio kriging ordinario",
             "Temperatura promedio kriging universal"),
  RMSE = c(crossval.ok[1, 2], rmse.uk))

comparison %>% 
  kable(col.names = c("Modelo", "RMSE"),
        caption = "Comparación de modelos") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Si bien presenta una disminución del RMSE que a priori parece no muy grande,
es fundamental tener en cuenta que esta métrica es de decrecimiento lento
cuando se acerca al cero por lo que dicho decremento realmente es una gran mejora
en el modelo. Adicionalmente, el ajuste a través de kriging universal presenta
una menor variabilidad en las estimaciones respecto a su similar, por lo que en
definitiva es el seleccionado entre todos los candidatos considerados previamente.

<!-- Simon -->
# Resultados ubicados geográficamente

## Ubicación de los puntos en el mapa

Incialmente se tiene una visualización de las unidades de muestreo en el mapa,
se cuenta con 25 puntos donde se tomaron mediciones tanto de la irradiación 
solar como de la temperatura como ya se había descrito anteriormente.

```{r, results='hide', warning=F}
plot(Indianashputm$geometry, main = "Puntos ubicados en el mapa de Indiana",
     axes = T, xaxt = "n", yaxt = "n")
points(spatial.points, col = "red", pch = 20, cex = 2)
```


Es importante saber donde se encuentran estas unidades ya que el kriging es un
método de interpolación exacto, por lo que el valor de las variables de 
interés tendrá el mismo valor de predicción que observado y esto es un
aspecto a tener en cuenta a la hora de hacer conclusiones.

## Puntos de predicción

Adicional a lo enunciado anteriormente, se presenta para información del lector,
aquellas ubicaciones geográficas sobre las cuales se realizaron las predicciones
usando el modelo seleccionado.

```{r}
grid_points <- st_sfc(st_multipoint(as.matrix(prediction_grid)))
st_crs(grid_points) <- CRS("+proj=utm +zone=16 ellps=WGS84")
Indianapoly <- st_transform(Indianashputm$geometry, CRS("+proj=utm +zone=16 ellps=WGS84"),"POLYGON")
grid_map <- st_intersection(Indianapoly, grid_points)
plot(grid_map, cex = 0.2, main = "Puntos de predicción", 
     axes = T, xaxt = "n", yaxt = "n")
```


## Presentación del mejor modelo

Llegados a este punto, se presenta el mejor modelo de entre todos los ajustados.

```{r}
pa1 <- readRDS("pa1.Rds")
pa2 <- readRDS("pa2.Rds")

ggpubr::ggarrange(pa1, pa2, ncol = 2)
```

De allí se puede observar que el modelo refleja los principios de autocorrelación 
espacial, puesto que se espera que lugares geográficos cercanos tengan valores
similares y lugares lejanos difieran en el valor de la variable regionalizada
en cuestión; lo que es una señal de buen ajuste.

# Conclusiones
<ul id="conc">
<li> En definitiva los tres primeros meses del año no son ideales para la siembra
de maíz, puesto que la temperatura está lejos de ser la requerida y en el mejor
de los casos se contará con lugares donde se alcance un máximo de 1 °C.</li>
<li> Como es de esperarse, el modelo es fiel a la realidad, pues este refleja
que los lugares tendrán menor temperatura entre más se encuentren al norte.</li>
<li> A medida que se aleja geográficamente de los puntos de muestreo, se tiene el
comportamiento natural de un aumento en la desviación estándar de las predicciones,
sin embargo se alcanza una incertidumbre máxima de 0.25 °C en promedio por lo que
se obtuvo no solo un buen ajuste, sino que uno muy fiable en lo que al error
de las estimaciones respecta.</li>
<li> Resulta de gran importancia considerar las tendencias que la respuesta pueda tener
con alguna dirección, pues al hacerlo es muy plausible que se pueda obtener mejoría a la
hora de analizar resultados en el proceso de modelamiento y predicción.</li>
<li> En definitiva el modelo gaussiano fue aquel que presentó mejor ajuste para
explicar la estructura de covarianza del proceso estocástico en cuestión.</li>
</ul>
